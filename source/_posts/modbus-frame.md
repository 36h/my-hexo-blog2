---
title: Modbus协议帧
date: 2020-02-12 14:46:03
tags: [翻译, 协议]
categories: [网络]
---
翻译来自Modbus协议ModbusPoll仿真器官网上的[协议解释](https://www.modbustools.com/modbus.html)，讲述不同功能码封包的格式。本文是人工翻译再加上自己在工作中的理解。
<!-- more -->
Modbus协议是通讯协议，广泛应用在设备之间的主从通讯。主站发送requset，从站作为response。Modbus协议与底层物理层无关。 其底层物理层常是RS232，RS422或RS485实现。

> 主站为master或者poll，从站为slave。

在标准的modbus系统中，只有一个master设备，和最多247个slave设备（[信息来源](https://www.picotech.com/library/oscilloscopes/modbus-serial-protocol-decoding)）

每个slave设备有一个唯一的地址，用一个字节表示，0表示广播地址，其余地址(1~247，最大支持247个slave设备)为其它设备所用。地址将出现在modbus帧中，用于区分本帧是发给哪个slave设备，地址有时候被称为slave ID，下文用slave ID来表示这个值。

## PDU

Protocol Data Units简称PDU，是Modbus协议帧最小单元，由“功能码”+“数据”两个字段组成。

### PDU与APU关系

PDU封包完成后，对PDU进行更高一层的封包叫APU，APU直接发送给目标设备。

他们两者关系是：
- PDU = Function code + Data
- ADU(ASCII或RTU) = Slave ID + PDU + Error check
- ADU(TCP) = MBAP + PDU

### 请求帧PDU

请求帧PDU的“功能码”字段，用于指示从设备要执行哪种操作。不同的功能码，“数据”字段有不同定义

以03H功能码为例，请求帧PDU的“数据”字段需要包含以下信息：
- 起始寄存器地址
- 要读多少个寄存器

### 回应帧

如果从站能正确处理请求，response的“功能码”字段与requset功能码一致。

如果从站不能处理请求或者发生错误，则slave会将错误代码替代原来的功能码回复给master端。错误代码的存在意义是让master端确认消息有效。

以03H功能码为例，若能正确处理，回应帧PDU“数据”字段需要包含以下信息：
- 有几个寄存器
- 这几个寄存器的内容

## 数据传输模式

常见的三种传输模式（transmission mode）为ASCII、RTU、TCP

### ASCII

数据每个字节(8bit)会被编码成两个字节(16bit)的ASCII字符。使用LRC作为校验和。

|有效码元|hex值|
|--|--|
|'0'-'9'|30H-31H|
|'A'-'F'|41H-46H|

该传输模式的主要优点是易于人类阅读究竟传输了什么字节，便于调试。

采用ASCII编码的APU帧结构如下表

|位置|起始|slave ID|功能码|数据N字节|LRC|末尾|
|--|--|--|--|--|--|--|
|帧内容|':'|2个ASCII|2个ASCII|2N个ASCII|2个ASCII|'\r\n'|

每一帧以冒号（:）字符（3AH）开头，并以回车换行符（CRLF）作为结束（0DH和0AH）。

### RTU

数据直接为二进制内容，报文必须以连续流的形式发送。使用CRC作为校验和。

采用RTU编码的APU帧结构如下表

|位置|起始|slave ID|功能码|数据N字节|CRC|末尾|
|--|--|--|--|--|--|--|
|帧内容|3.5字符时间|1字节|1字节|N字节|2字节|3.5字符时间|

上表提到的字符时间对于串口传输有要求
- 整个消息帧必须作为连续流传输。 如果在完成帧之前发生超过1.5个字符时间的静默间隔，则接收设备将丢弃未完成的消息，并假定下一个字节将是新消息的地址字段。
- 如果新消息在前一条消息之后的3.5个字符时间之前开始，则接收设备将认为它是前一条消息的延续。会返回modbus错误。

### TCP

基于以太网TCP/IP的TCP传输模式，适用于TCP或者UDP连接，默认端口为502。

要学习ModbusTCP，需要先了解MBAP包头，MBAP是ModbusTCP帧前7个字节。

MBAP主要有以下几个字段

|字段|字节数|功能
|--|--|--|
|Transaction ID|2|事务ID，默认值0，通常在于并发通讯中，区分不同的事务。常用于master在某时刻并发发送多个请求，而不必每次请求都要按顺序阻塞等待slave回复的场合|
|Protocol ID|2|协议ID，默认值0，区分协议，这个字段很像HTTP1.0、1.1、2.0的区别，用于用户自行实现特定的协议，比如值0表示标准的Modbus TCP协议，值1表示用户实现加长版的数据帧，支持每帧10000字节传输，值2表示用户实现的一帧实现5个非连续的寄存器读取等等|
|Length|2|表示从长度字段后开始计算，本帧有多少字节|
|Unit ID|1|默认值0，类似于RTU中的Slave ID，用于非TCP/IP协议栈的场合，如桥接网卡下的区分对端。在标准TCP/IP协议下，此字段的值可以忽略，因为TCP/IP模型默认已经是一对一通讯，不需要区分对端。|

Modbus TCP数据帧实际上是PDU加上7字节的MBAP而成。如下图，展示了Modbus TCP与PDU的关系

![](/images/modbus-frame/modbus-tcp-apu.png)


帧格式

|位置|Tran. ID|Prot. ID|Length|Unit ID|功能码|数据N字节|
|--|--|--|--|--|--|--|
|帧内容|2字节|2字节|2字节|1字节|1字节|N字节|

备注
- Modbus TCP中PDU的编码方式，没有特别标明为ASCII还是RTU。为了提高传输效率，默认情况下为RTU，即直接二进制发送，而不经过复杂ASCII编码。
- Modbus TCP协议有几种变种，如Modbus RTU over TCP/IP，其定义为Modbus TCP加上CRC末尾。不同变种可以参考[维基百科](https://en.wikipedia.org/wiki/Modbus#Protocol_versions)

## 常见功能码

功能码基本上是根据PLC术语定义的。

|PLC英文|术语|理解|数据类型|
|--|--|--|--|
|Coil|线圈|开关输出信号，可读写|布尔型|
|Discrete Input|离散量|输入信号，不能被写入|布尔型|
|Input Register|输入寄存器|只能读，不能被写入|WORD,2字节|
|Holding Register|保持寄存器|可读写|WORD,2字节|

我习惯按读取数据类型分类功能号。参考[常见的功能号]([http://www.simplymodbus.ca/FC01.htm](http://www.simplymodbus.ca/FC01.htm))

下表是读写布尔型（点击中文，电梯直达）：

|功能十进制|十六进制|英文|中文|最小数据单位|
|--|--|--|--|--|
|01|01|Read Coils|[读多个线圈](#读多个线圈)|bit（布尔值）|
|05|05|Write Single Coils|[写单个线圈](#写单个线圈)|bit（布尔值）|
|15|0F|Write Multiple Coils|[写多个线圈](#写多个线圈)|bit（布尔值）|
|02|02|Read Discrete Inputs|[读多个离散输入](读多个离散输入)|bit（布尔值）|

下表是读写16bit数据（点击中文，电梯直达）：

|功能十进制|十六进制|英文|中文|最小数据单位|
|--|--|--|--|--|
|04|04|Read Input Register|[读多个输入寄存器](#读多个输入寄存器)|16bit|
|03|03|Read Holding Registers|[读多个保持寄存器](#读多个保持寄存器)|16bit|
|06|06|Write Single Register|[写单个保持寄存器](#写单个保持寄存器)|16bit|
|16|10|Write Multiple Registers|[写多个保持寄存器](#写多个保持寄存器)|16bit|

这些各种骚操作都是在PDU层，即只考虑“功能码”+“数据”，与ASCII和RTU等传输模式无关。

当PDU构造好后，才进行对应的ASCII、RTU、TCP等通讯模式封包。

以下读写布尔/16bit时，注意本PLC地址的实际偏移值

- 线圈：在PLC中是从1开始表示第一个，在PDU封包时从0开始表示第一个。
- 离散输入：在PLC中是从10001开始表示第一个，在PDU封包时是从0开始表示第一个。
- 输入寄存器：在PLC中是从30001开始表示第一个,在PDU封包时是从0开始表示第一个。

### 读写布尔型

#### 读多个线圈

读取PLC中从20到56号的线圈状态

master请求帧PDU

    01 0013 0025

- 01: 功能号01H
- 0013: 0013H是十进制19，对应线圈20号
- 0025: 25H是十进制37，20到56共有37个线圈

slave回应帧PDU

    01 05 CD6BB20E1B

- 01: 功能号01H
- 05: 接下来有5个字节(37/8=5bytes)
- CD: 线圈 27 - 20 (1100 1101) 高位为线圈27，低位为线圈20
- 6B: 线圈 35 - 28 (0110 1011)
- B2: 线圈 43 - 36 (1011 0010)
- 0E: 线圈 51 - 44 (0000 1110) 
- 1B: 线圈 56 - 52 (0001 1011) 最后一字节仅提供低5位信息，其余位用0填充

返回的线圈每字节的高位比特，表示线圈数较大的布尔值；低位比特，表示线圈较小的布尔值。如上回复中，线圈43为高电平，线圈36为低电平。

#### 写单个线圈

写PLC线圈173号，设置为高电平（ON）

master请求帧PDU

    05 00AC FF00

- 05: 功能号05H
- 00AC: ACH对应十进制172，对应线圈173号
- FF00: 高电平，( FF00 = ON,  0000 = OFF )

若slave回应正常，则返回与master请求的相同PDU给master

    05 00AC FF00

#### 写多个线圈

将PLC中线圈20到29写入新的值

master请求帧PDU

    0F 0013 000A 02 CD01

- 0F: 功能号0FH
- 0013: 13H对应十进制19，对应线圈20号
- 000A: 0AH对应十进制10，写入10个线圈（从20到29）
- 02: 接下来有2个字节(10/8=2bytes)
- CD: 线圈 27 - 20 (1100 1101) 高位为线圈27，低位为线圈20
- 01: 线圈 29 - 28 (0000 0001) 最后一字节仅提供低2位信息，其余位用0填充

返回的线圈每字节的高位比特，表示线圈数较大的布尔值；低位比特，表示线圈较小的布尔值。如上请求中，线圈20为高电平，线圈21为低电平。

slave回应帧PDU

    0F 0013 000A

- 0F: 功能号0FH
- 0013: 13H对应十进制19，对应线圈20号
- 000A: 0AH对应十进制10，写入10个线圈（从20到29）

#### 读多个离散输入

从PLC中读取从10197到10218离散输入。

master请求帧PDU

    02 00C4 0016

- 02: 功能号02H
- 00C4: 00C4H对应十进制196，196+10001=10197，表示离散输入的起点
- 0016: 16H对应十进制22，表示读取22个离散输入（从10197到10218）

slave回应帧PDU

    02 03 ACDB35

- 02: 功能号02H
- 03: 接下来有2个字节(22/8=3 bytes)
- AC: 离散输入 10204 - 10197 (1010 1100) 高位为10204，低位为10197
- DB: 离散输入 10212 - 10205 (1101 1011)
- 35: 离散输入 10218 - 10213 (0011 0101) 最后一字节仅提供低6位信息，其余位用0填充

返回的线圈每字节的高位比特，表示线圈数较大的布尔值；低位比特，表示线圈较小的布尔值。如上回应中，离散10204为高电平，离散10197为低电平。

### 读写16位

#### 读多个输入寄存器

从PLC读取2个输入寄存器的值，从30009开始。

master请求帧PDU

    04 0008 0001

- 04: 功能号04H
- 0008: 8H对应十进制8，对应8+30001=30009输入寄存器
- 0002: 读取2个寄存器

slave回应帧PDU

    04 04 000A0003

- 04: 功能号04H
- 04: 接下来有4个字节，对应2个输入寄存器（16bit x 2 = 32bit）
- 000A: 输入寄存器30009的值
- 0003: 输入寄存器30010的值

#### 读多个保持寄存器

与[读多个输入寄存器](#读多个输入寄存器)操作一致。

#### 写单个保持寄存器

向PLC保持寄存器40002写入新的值

master请求帧PDU

    06 0001 0003

06: 功能号06H
0001: 1H对应十进制1，对应1+40001=40002输入寄存器
0003: 新的值

若slave回应正常，则返回与master请求的相同PDU给master

#### 写多个保持寄存器

向PLC保持寄存器40002和40003写入新的值。

master请求帧PDU

    10 0001 0002 04 000A 0102

10: 功能号10H
0001: 1H对应十进制1，对应1+40001=40002输入寄存器
0002: 寄存器个数=2
04: 接下来有4个字节 (2寄存器 x 2字节 = 4)
000A: 寄存器 40002 的新值
0102: 寄存器 40003 的新值

slave回应帧PDU

    10 0001 0002

10: 功能号10H
0001: 1H对应十进制1，对应1+40001=40002输入寄存器
0002: 寄存器个数=2

#### TODO

TODO: 字节顺序。。。大端等。。。

## 参考文章

实际上，如果整个主从设备都是自己设计，就无所谓什么读保持寄存器还是写保持寄存器，可能只用到两个功能号（03H和10H），如果是主从设备其中一个是别人做的，大家就必须要遵守Modbus通用协议了。

[Modbus interface tutorial](https://www.lammertbies.nl/comm/info/modbus)